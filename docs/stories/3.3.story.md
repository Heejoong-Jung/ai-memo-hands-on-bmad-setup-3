# Story 3.3: 음성인식 고급 기능 및 최적화

## Status

Draft

---

## Story

**As a** 사용자,  
**I want** 음성인식 기능이 시각적으로 풍부하고 최적화된 경험을 제공하여,  
**so that** 더욱 직관적이고 효율적으로 음성 메모를 작성할 수 있다.

---

## Acceptance Criteria

1. 음성 입력 상태를 시각적으로 표시해야 한다 (파형, 볼륨 레벨)
2. 음성 인식 품질을 실시간으로 모니터링할 수 있어야 한다
3. 노이즈 캔슬링 및 음성 품질 최적화 기능이 있어야 한다
4. 음성 인식 결과의 편집 및 수정 기능이 있어야 한다
5. 음성 메모와 텍스트 메모를 통합하여 관리할 수 있어야 한다
6. 음성 인식 성능 통계를 제공해야 한다 (정확도, 처리 시간)
7. 사용자 설정을 통해 음성 인식 옵션을 조정할 수 있어야 한다
8. 접근성을 고려한 키보드 단축키 지원이 있어야 한다
9. 모든 기능에 대한 단위 테스트 및 통합 테스트를 작성해야 한다

---

## Tasks / Subtasks

- [ ] Task 1: 시각적 피드백 시스템 구현 (AC: 1, 2)
  - [ ] `lib/speech/audio-visualizer.ts` 파일 생성
  - [ ] 실시간 오디오 파형 시각화
  - [ ] 볼륨 레벨 표시 및 모니터링
  - [ ] 음성 인식 품질 지표 표시
  - [ ] 단위 테스트 작성

- [ ] Task 2: 음성 품질 최적화 시스템 구현 (AC: 3)
  - [ ] `lib/speech/audio-processor.ts` 파일 생성
  - [ ] 노이즈 캔슬링 알고리즘 구현
  - [ ] 음성 품질 분석 및 개선
  - [ ] 자동 게인 조절 기능
  - [ ] 단위 테스트 작성

- [ ] Task 3: 고급 UI 컴포넌트 구현 (AC: 1, 4, 7)
  - [ ] `components/speech/audio-visualizer.tsx` 컴포넌트 생성
  - [ ] 파형 및 볼륨 레벨 시각화
  - [ ] 음성 인식 결과 편집 인터페이스
  - [ ] 사용자 설정 패널
  - [ ] 컴포넌트 테스트 작성

- [ ] Task 4: 음성-텍스트 통합 관리 시스템 (AC: 5)
  - [ ] `lib/speech/voice-text-manager.ts` 파일 생성
  - [ ] 음성 메모와 텍스트 메모 통합 관리
  - [ ] 하이브리드 입력 모드 지원
  - [ ] 메모 타입별 분류 및 관리
  - [ ] 단위 테스트 작성

- [ ] Task 5: 성능 모니터링 및 통계 시스템 (AC: 6)
  - [ ] `lib/speech/performance-monitor.ts` 파일 생성
  - [ ] 음성 인식 정확도 측정
  - [ ] 처리 시간 통계 수집
  - [ ] 사용자 행동 분석
  - [ ] 단위 테스트 작성

- [ ] Task 6: 접근성 및 사용성 개선 (AC: 8)
  - [ ] 키보드 단축키 지원 구현
  - [ ] 스크린 리더 호환성 개선
  - [ ] 고대비 모드 지원
  - [ ] 사용자 가이드 및 도움말
  - [ ] 통합 테스트 작성

- [ ] Task 7: 통합 테스트 및 사용성 검증 (AC: 9)
  - [ ] 전체 고급 기능 플로우 테스트
  - [ ] 성능 벤치마크 테스트
  - [ ] 접근성 준수 검증
  - [ ] 사용자 경험 최적화 테스트

---

## Dev Notes

### 기술 스택 및 아키텍처 컨텍스트

**오디오 시각화**
- Web Audio API 사용
- 실시간 오디오 분석
- Canvas 또는 SVG 기반 시각화
- 성능 최적화된 렌더링
[Source: Web Audio API 문서]

**음성 품질 최적화**
- 노이즈 캔슬링 알고리즘
- 자동 게인 조절
- 주파수 분석 및 필터링
- 실시간 오디오 처리
[Source: Web Audio API 문서]

**성능 모니터링**
- 음성 인식 정확도 측정
- 처리 시간 통계
- 사용자 행동 분석
- 성능 지표 수집
[Source: docs/epics/epic-3-voice-memo.md]

### Epic 컨텍스트

**Epic 3: 음성인식 메모 작성**
- 음성인식 정확도 95% 이상 목표
- 음성-텍스트 변환 지연시간 2초 이내
- 음성 기능 관련 에러율 3% 미만
- 접근성 향상을 통한 사용자층 확대
[Source: docs/epics/epic-3-voice-memo.md]

### 이전 스토리에서의 주요 인사이트

**Story 3.2: 실시간 음성-텍스트 변환 완료**
- `lib/speech/voice-recognition.ts`: 음성 인식 엔진
- `components/speech/voice-recognition.tsx`: 기본 UI 컴포넌트
- 실시간 텍스트 처리 및 에러 핸들링
- 노트 작성 폼과의 통합
[Source: docs/stories/3.2.story.md]

**Story 3.1: 음성인식 시스템 초기 설정 완료**
- `lib/speech/speech-recognition.ts`: SpeechRecognition 초기화
- `lib/speech/permission-manager.ts`: 권한 상태 관리
- `lib/speech/speech-utils.ts`: 브라우저 호환성 검사
- 한국어 설정 및 에러 핸들링 패턴
[Source: docs/stories/3.1.story.md]

### 파일 위치 및 구조

**새로 생성할 파일:**
- `lib/speech/audio-visualizer.ts` - 오디오 시각화 엔진
- `lib/speech/audio-processor.ts` - 음성 품질 최적화
- `lib/speech/voice-text-manager.ts` - 음성-텍스트 통합 관리
- `lib/speech/performance-monitor.ts` - 성능 모니터링
- `components/speech/audio-visualizer.tsx` - 시각화 UI 컴포넌트
- `components/speech/voice-settings.tsx` - 사용자 설정 UI
- `lib/speech/audio-visualizer.test.ts` - 시각화 테스트
- `lib/speech/audio-processor.test.ts` - 오디오 처리 테스트
- `lib/speech/voice-text-manager.test.ts` - 통합 관리 테스트
- `lib/speech/performance-monitor.test.ts` - 성능 모니터링 테스트
- `components/speech/audio-visualizer.test.tsx` - 시각화 UI 테스트
- `components/speech/voice-settings.test.tsx` - 설정 UI 테스트

### 구현 가이드라인

**오디오 시각화 엔진 예시:**

```typescript
// lib/speech/audio-visualizer.ts
// 실시간 오디오 시각화 및 분석
// Web Audio API를 활용한 파형 및 볼륨 레벨 표시
// 관련 파일: components/speech/audio-visualizer.tsx, lib/speech/voice-recognition.ts

export interface AudioVisualizerConfig {
  canvasWidth: number;
  canvasHeight: number;
  barCount: number;
  barWidth: number;
  barSpacing: number;
  colors: {
    background: string;
    bar: string;
    peak: string;
  };
}

export interface AudioData {
  frequencyData: Uint8Array;
  timeDomainData: Uint8Array;
  volume: number;
  peak: number;
}

export class AudioVisualizer {
  private audioContext: AudioContext | null = null;
  private analyser: AnalyserNode | null = null;
  private dataArray: Uint8Array | null = null;
  private animationId: number | null = null;
  private config: AudioVisualizerConfig;
  private onDataUpdate?: (data: AudioData) => void;

  constructor(config: Partial<AudioVisualizerConfig> = {}) {
    this.config = {
      canvasWidth: 400,
      canvasHeight: 100,
      barCount: 32,
      barWidth: 8,
      barSpacing: 2,
      colors: {
        background: '#1a1a1a',
        bar: '#4ade80',
        peak: '#f59e0b',
      },
      ...config,
    };
  }

  /**
   * 오디오 시각화 초기화
   */
  async initialize(stream: MediaStream): Promise<void> {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      const source = this.audioContext.createMediaStreamSource(stream);

      // 분석기 설정
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      
      // 데이터 배열 초기화
      const bufferLength = this.analyser.frequencyBinCount;
      this.dataArray = new Uint8Array(bufferLength);

      // 오디오 그래프 연결
      source.connect(this.analyser);

      // 시각화 시작
      this.startVisualization();
    } catch (error) {
      console.error('오디오 시각화 초기화 실패:', error);
      throw error;
    }
  }

  /**
   * 시각화 시작
   */
  private startVisualization(): void {
    if (!this.analyser || !this.dataArray) return;

    const animate = () => {
      this.analyser!.getByteFrequencyData(this.dataArray!);
      this.analyser!.getByteTimeDomainData(this.dataArray!);

      // 볼륨 및 피크 계산
      const volume = this.calculateVolume(this.dataArray!);
      const peak = this.calculatePeak(this.dataArray!);

      // 데이터 업데이트 콜백 호출
      this.onDataUpdate?.({
        frequencyData: this.dataArray!,
        timeDomainData: this.dataArray!,
        volume,
        peak,
      });

      this.animationId = requestAnimationFrame(animate);
    };

    animate();
  }

  /**
   * 볼륨 계산
   */
  private calculateVolume(data: Uint8Array): number {
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      sum += data[i];
    }
    return sum / data.length / 255;
  }

  /**
   * 피크 계산
   */
  private calculatePeak(data: Uint8Array): number {
    let peak = 0;
    for (let i = 0; i < data.length; i++) {
      if (data[i] > peak) {
        peak = data[i];
      }
    }
    return peak / 255;
  }

  /**
   * 데이터 업데이트 콜백 설정
   */
  setOnDataUpdate(callback: (data: AudioData) => void): void {
    this.onDataUpdate = callback;
  }

  /**
   * 시각화 중지
   */
  stop(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  /**
   * 리소스 정리
   */
  destroy(): void {
    this.stop();
    
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    
    this.analyser = null;
    this.dataArray = null;
  }
}
```

**음성 품질 최적화 예시:**

```typescript
// lib/speech/audio-processor.ts
// 음성 품질 최적화 및 노이즈 캔슬링
// Web Audio API를 활용한 실시간 오디오 처리
// 관련 파일: lib/speech/audio-visualizer.ts, lib/speech/voice-recognition.ts

export interface AudioProcessorConfig {
  noiseReduction: boolean;
  autoGain: boolean;
  highPassFilter: boolean;
  lowPassFilter: boolean;
  gainLevel: number;
}

export class AudioProcessor {
  private audioContext: AudioContext | null = null;
  private source: MediaStreamAudioSourceNode | null = null;
  private analyser: AnalyserNode | null = null;
  private gainNode: GainNode | null = null;
  private highPassFilter: BiquadFilterNode | null = null;
  private lowPassFilter: BiquadFilterNode | null = null;
  private config: AudioProcessorConfig;

  constructor(config: Partial<AudioProcessorConfig> = {}) {
    this.config = {
      noiseReduction: true,
      autoGain: true,
      highPassFilter: true,
      lowPassFilter: true,
      gainLevel: 1.0,
      ...config,
    };
  }

  /**
   * 오디오 처리 초기화
   */
  async initialize(stream: MediaStream): Promise<MediaStream> {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      // 오디오 그래프 구성
      this.source = this.audioContext.createMediaStreamSource(stream);
      this.analyser = this.audioContext.createAnalyser();
      this.gainNode = this.audioContext.createGain();

      // 필터 설정
      if (this.config.highPassFilter) {
        this.highPassFilter = this.audioContext.createBiquadFilter();
        this.highPassFilter.type = 'highpass';
        this.highPassFilter.frequency.value = 80; // 80Hz 이하 제거
      }

      if (this.config.lowPassFilter) {
        this.lowPassFilter = this.audioContext.createBiquadFilter();
        this.lowPassFilter.type = 'lowpass';
        this.lowPassFilter.frequency.value = 8000; // 8kHz 이상 제거
      }

      // 게인 설정
      this.gainNode.gain.value = this.config.gainLevel;

      // 오디오 그래프 연결
      this.connectAudioGraph();

      // 자동 게인 조절 시작
      if (this.config.autoGain) {
        this.startAutoGain();
      }

      // 처리된 오디오 스트림 반환
      const destination = this.audioContext.createMediaStreamDestination();
      this.gainNode.connect(destination);
      
      return destination.stream;
    } catch (error) {
      console.error('오디오 처리 초기화 실패:', error);
      throw error;
    }
  }

  /**
   * 오디오 그래프 연결
   */
  private connectAudioGraph(): void {
    if (!this.source || !this.analyser || !this.gainNode) return;

    let currentNode: AudioNode = this.source;

    // 고역 통과 필터 연결
    if (this.highPassFilter) {
      currentNode.connect(this.highPassFilter);
      currentNode = this.highPassFilter;
    }

    // 저역 통과 필터 연결
    if (this.lowPassFilter) {
      currentNode.connect(this.lowPassFilter);
      currentNode = this.lowPassFilter;
    }

    // 게인 노드 연결
    currentNode.connect(this.gainNode);
    this.gainNode.connect(this.analyser);
  }

  /**
   * 자동 게인 조절 시작
   */
  private startAutoGain(): void {
    if (!this.analyser || !this.gainNode) return;

    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    
    const adjustGain = () => {
      this.analyser!.getByteFrequencyData(dataArray);
      
      // 평균 볼륨 계산
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const averageVolume = sum / dataArray.length / 255;

      // 게인 조절 (목표 볼륨: 0.3)
      const targetVolume = 0.3;
      const currentGain = this.gainNode!.gain.value;
      
      if (averageVolume > 0.01) { // 무음이 아닌 경우에만 조절
        const newGain = currentGain * (targetVolume / averageVolume);
        const clampedGain = Math.max(0.1, Math.min(3.0, newGain)); // 0.1 ~ 3.0 범위로 제한
        
        this.gainNode!.gain.setValueAtTime(clampedGain, this.audioContext!.currentTime);
      }

      requestAnimationFrame(adjustGain);
    };

    adjustGain();
  }

  /**
   * 설정 업데이트
   */
  updateConfig(newConfig: Partial<AudioProcessorConfig>): void {
    this.config = { ...this.config, ...newConfig };

    if (this.gainNode && newConfig.gainLevel !== undefined) {
      this.gainNode.gain.value = newConfig.gainLevel;
    }
  }

  /**
   * 리소스 정리
   */
  destroy(): void {
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
    
    this.source = null;
    this.analyser = null;
    this.gainNode = null;
    this.highPassFilter = null;
    this.lowPassFilter = null;
  }
}
```

**성능 모니터링 시스템 예시:**

```typescript
// lib/speech/performance-monitor.ts
// 음성 인식 성능 모니터링 및 통계 수집
// 정확도, 처리 시간, 사용자 행동 분석
// 관련 파일: lib/speech/voice-recognition.ts, components/speech/voice-settings.tsx

export interface PerformanceMetrics {
  recognitionAccuracy: number;
  averageProcessingTime: number;
  totalRecognitions: number;
  successfulRecognitions: number;
  failedRecognitions: number;
  averageConfidence: number;
  userSatisfaction: number;
}

export interface RecognitionSession {
  id: string;
  startTime: number;
  endTime: number;
  duration: number;
  confidence: number;
  accuracy: number;
  textLength: number;
  errorType?: string;
}

export class PerformanceMonitor {
  private sessions: RecognitionSession[] = [];
  private currentSession: RecognitionSession | null = null;
  private metrics: PerformanceMetrics;
  private onMetricsUpdate?: (metrics: PerformanceMetrics) => void;

  constructor() {
    this.metrics = {
      recognitionAccuracy: 0,
      averageProcessingTime: 0,
      totalRecognitions: 0,
      successfulRecognitions: 0,
      failedRecognitions: 0,
      averageConfidence: 0,
      userSatisfaction: 0,
    };
  }

  /**
   * 인식 세션 시작
   */
  startSession(): string {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    this.currentSession = {
      id: sessionId,
      startTime: Date.now(),
      endTime: 0,
      duration: 0,
      confidence: 0,
      accuracy: 0,
      textLength: 0,
    };

    return sessionId;
  }

  /**
   * 인식 세션 종료
   */
  endSession(sessionId: string, confidence: number, textLength: number, errorType?: string): void {
    if (!this.currentSession || this.currentSession.id !== sessionId) {
      return;
    }

    this.currentSession.endTime = Date.now();
    this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;
    this.currentSession.confidence = confidence;
    this.currentSession.textLength = textLength;
    this.currentSession.accuracy = this.calculateAccuracy(confidence, textLength);
    
    if (errorType) {
      this.currentSession.errorType = errorType;
    }

    this.sessions.push(this.currentSession);
    this.updateMetrics();
    this.currentSession = null;
  }

  /**
   * 정확도 계산
   */
  private calculateAccuracy(confidence: number, textLength: number): number {
    // 신뢰도와 텍스트 길이를 기반으로 정확도 계산
    const confidenceWeight = 0.7;
    const lengthWeight = 0.3;
    
    const confidenceScore = confidence;
    const lengthScore = Math.min(textLength / 100, 1); // 100자 이상이면 최대 점수
    
    return (confidenceScore * confidenceWeight) + (lengthScore * lengthWeight);
  }

  /**
   * 메트릭 업데이트
   */
  private updateMetrics(): void {
    if (this.sessions.length === 0) return;

    const successfulSessions = this.sessions.filter(s => !s.errorType);
    const failedSessions = this.sessions.filter(s => s.errorType);

    this.metrics.totalRecognitions = this.sessions.length;
    this.metrics.successfulRecognitions = successfulSessions.length;
    this.metrics.failedRecognitions = failedSessions.length;
    
    if (successfulSessions.length > 0) {
      this.metrics.recognitionAccuracy = 
        successfulSessions.reduce((sum, s) => sum + s.accuracy, 0) / successfulSessions.length;
      
      this.metrics.averageProcessingTime = 
        successfulSessions.reduce((sum, s) => sum + s.duration, 0) / successfulSessions.length;
      
      this.metrics.averageConfidence = 
        successfulSessions.reduce((sum, s) => sum + s.confidence, 0) / successfulSessions.length;
    }

    // 사용자 만족도 계산 (성공률 기반)
    this.metrics.userSatisfaction = this.metrics.successfulRecognitions / this.metrics.totalRecognitions;

    this.onMetricsUpdate?.(this.metrics);
  }

  /**
   * 메트릭 업데이트 콜백 설정
   */
  setOnMetricsUpdate(callback: (metrics: PerformanceMetrics) => void): void {
    this.onMetricsUpdate = callback;
  }

  /**
   * 현재 메트릭 반환
   */
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  /**
   * 세션 히스토리 반환
   */
  getSessionHistory(): RecognitionSession[] {
    return [...this.sessions];
  }

  /**
   * 통계 초기화
   */
  reset(): void {
    this.sessions = [];
    this.currentSession = null;
    this.metrics = {
      recognitionAccuracy: 0,
      averageProcessingTime: 0,
      totalRecognitions: 0,
      successfulRecognitions: 0,
      failedRecognitions: 0,
      averageConfidence: 0,
      userSatisfaction: 0,
    };
  }
}
```

### 의존성

**선행 스토리:**
- Story 3.1: 음성인식 시스템 초기 설정 (완료)
- Story 3.2: 실시간 음성-텍스트 변환 (완료)

**후속 스토리:**
- 없음 (에픽3 완료)

**블로킹 없음:**
- 이 스토리는 독립적으로 구현 가능
- 기본 음성인식 기능이 완료됨

### Testing

**테스트 프레임워크:**
- Vitest + TypeScript
- jsdom 환경에서 브라우저 API 모킹

**단위 테스트:**
- `AudioVisualizer` 클래스 테스트
  - 초기화 성공/실패 확인
  - 오디오 데이터 분석 확인
  - 시각화 시작/중지 확인
- `AudioProcessor` 클래스 테스트
  - 오디오 처리 초기화 확인
  - 필터 적용 확인
  - 자동 게인 조절 확인
- `PerformanceMonitor` 클래스 테스트
  - 세션 관리 확인
  - 메트릭 계산 확인
  - 통계 수집 확인

**통합 테스트:**
- 고급 기능 통합 플로우 테스트
- 성능 벤치마크 테스트
- 접근성 준수 검증

**모킹 전략:**
- Web Audio API 모킹
- MediaStream 모킹
- Canvas API 모킹
- 성능 측정 API 모킹

**테스트 케이스:**
1. **오디오 시각화**
   - 파형 표시 확인
   - 볼륨 레벨 표시 확인
   - 실시간 업데이트 확인

2. **음성 품질 최적화**
   - 노이즈 캔슬링 확인
   - 자동 게인 조절 확인
   - 필터 적용 확인

3. **성능 모니터링**
   - 정확도 측정 확인
   - 처리 시간 통계 확인
   - 사용자 행동 분석 확인

4. **접근성**
   - 키보드 단축키 확인
   - 스크린 리더 호환성 확인
   - 고대비 모드 확인

**테스트 실행:**
- `pnpm test` - 전체 테스트 suite 실행
- `pnpm test lib/speech` - Speech 관련 테스트만 실행
- `pnpm test components/speech` - Speech UI 테스트만 실행

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Story 3.3 통합 버전 생성 | Bob (Scrum Master) |

---

## Dev Agent Record

_[Dev Agent가 구현 시 작성]_

---

## QA Results

_[QA Agent가 작성]_
